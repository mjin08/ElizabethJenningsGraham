{"ast":null,"code":"var _jsxFileName = \"/Users/maggiejin/cse495/lizzie-graham/src/screens/PlayerWindow.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\n\n// Import bundled idle assets (these files exist in the project)\nimport idle1 from '../assets/idle/idle1.mp4';\nimport idle2 from '../assets/idle/idle2.mp4';\nimport idle3 from '../assets/idle/idle3.mp4';\nimport idle4 from '../assets/idle/idle4.mp4';\n\n// Import only the answer file that was uploaded\nimport whoAreYou from '../assets/answers/who_are_you.mp4';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst idleVideos = [idle1, idle2, idle3, idle4].filter(Boolean);\nexport default function PlayerWindow() {\n  _s();\n  // two video elements for double-buffering (crossfade)\n  const videoRefs = [useRef(null), useRef(null)];\n  const [active, setActive] = useState(0); // which video element is currently visible (0 or 1)\n  const [srcs, setSrcs] = useState([idleVideos.length ? idleVideos[Math.floor(Math.random() * idleVideos.length)] : '', '']);\n  const intervalRef = useRef(null);\n  const rotationActiveRef = useRef(true);\n  useEffect(() => {\n    let mounted = true;\n    let storageHandler = null;\n    function startIdleRotation() {\n      if (intervalRef.current) clearInterval(intervalRef.current);\n      if (!idleVideos.length) return;\n      rotationActiveRef.current = true;\n      intervalRef.current = setInterval(() => {\n        if (!mounted) return;\n        if (!rotationActiveRef.current) return;\n        const next = idleVideos[Math.floor(Math.random() * idleVideos.length)];\n        crossfadeTo(next, {\n          loop: true,\n          muted: true\n        });\n      }, 7000);\n    }\n    function stopIdleRotation() {\n      rotationActiveRef.current = false;\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    }\n    startIdleRotation();\n\n    // Listen for broadcast messages to play answer\n    let ch;\n    if ('BroadcastChannel' in window) {\n      ch = new BroadcastChannel('graham-player-channel');\n      ch.onmessage = ev => {\n        const data = ev.data;\n        if (!data) return;\n        if (data.type === 'playAnswer' && data.questionId) {\n          console.log('Received playAnswer for', data.questionId);\n        }\n        if (data.type === 'playAnswerSpoken' && data.text) {\n          const text = (data.text || '').toLowerCase();\n          if (text.includes('who are you') || text.includes(\"who're you\") || text.includes(\"who r u\")) {\n            if (whoAreYou) playAnswerOnce(whoAreYou);\n            return;\n          }\n        }\n        if (data.type === 'ping') {\n          // no-op: ensure player is awake\n        }\n      };\n    } else {\n      // fallback: listen to storage events\n      storageHandler = ev => {\n        if (ev.key === 'graham-player-msg' && ev.newValue) {\n          try {\n            const data = JSON.parse(ev.newValue);\n            if (data.type === 'playAnswerSpoken' && data.text) {\n              const text = (data.text || '').toLowerCase();\n              if (text.includes('who are you')) {\n                if (whoAreYou) playAnswerOnce(whoAreYou);\n              }\n            }\n          } catch (e) {}\n        }\n      };\n      window.addEventListener('storage', storageHandler);\n    }\n    function crossfadeTo(nextSrc, opts = {}) {\n      if (!nextSrc) return;\n      const inactive = 1 - active;\n\n      // set the src on the inactive video element\n      setSrcs(prev => {\n        const n = [...prev];\n        n[inactive] = nextSrc;\n        return n;\n      });\n\n      // Once the inactive video can play, start it and fade\n      const onCanPlay = () => {\n        const activeEl = videoRefs[active].current;\n        const inactiveEl = videoRefs[inactive].current;\n        if (!inactiveEl) return;\n        try {\n          inactiveEl.loop = !!opts.loop;\n          inactiveEl.muted = opts.muted === undefined ? inactiveEl.muted : opts.muted;\n          const p = inactiveEl.play();\n          if (p && p.catch) p.catch(() => {/* autoplay blocked */});\n        } catch (e) {}\n\n        // small timeout to ensure play has started before fade\n        setTimeout(() => {\n          // fade by switching active index (opacity transition in JSX)\n          setActive(inactive);\n\n          // pause previous after fade completes to avoid decoding both endlessly\n          setTimeout(() => {\n            try {\n              if (activeEl) {\n                activeEl.pause();\n              }\n            } catch (e) {}\n          }, 350);\n        }, 80);\n        inactiveEl.removeEventListener('canplay', onCanPlay);\n      };\n\n      // attach handler; if already ready, call immediately\n      const inactiveEl = videoRefs[inactive].current;\n      if (inactiveEl) {\n        inactiveEl.addEventListener('canplay', onCanPlay);\n        // ensure it begins loading\n        try {\n          inactiveEl.load();\n        } catch (e) {}\n        // if already have readyState enough, call handler\n        if (inactiveEl.readyState >= 3) {\n          onCanPlay();\n        }\n      }\n    }\n    function playAnswerOnce(answerSrc) {\n      if (!answerSrc) return;\n      stopIdleRotation();\n\n      // Prepare inactive video to play the answer (no loop, not muted)\n      const inactive = 1 - active;\n      setSrcs(prev => {\n        const n = [...prev];\n        n[inactive] = answerSrc;\n        return n;\n      });\n      const inactiveEl = videoRefs[inactive].current;\n      const onEnded = () => {\n        if (!mounted) return;\n        // after short delay, resume idle rotation and pick a random idle\n        setTimeout(() => {\n          if (!mounted) return;\n          const next = idleVideos.length ? idleVideos[Math.floor(Math.random() * idleVideos.length)] : '';\n          crossfadeTo(next, {\n            loop: true,\n            muted: true\n          });\n          startIdleRotation();\n        }, 800);\n        if (inactiveEl) inactiveEl.removeEventListener('ended', onEnded);\n      };\n      if (inactiveEl) {\n        inactiveEl.loop = false;\n        inactiveEl.muted = false;\n        inactiveEl.addEventListener('ended', onEnded);\n        // ensure it loads and plays; crossfadeTo helper will play when ready\n        const playHelper = () => crossfadeTo(answerSrc, {\n          loop: false,\n          muted: false\n        });\n        playHelper();\n      }\n    }\n    return () => {\n      mounted = false;\n      rotationActiveRef.current = false;\n      if (intervalRef.current) clearInterval(intervalRef.current);\n      if (ch) ch.close && ch.close();\n      if (storageHandler) window.removeEventListener('storage', storageHandler);\n    };\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-wrap\",\n    style: {\n      height: '100vh',\n      background: '#000',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      position: 'relative',\n      overflow: 'hidden'\n    },\n    children: srcs[0] || srcs[1] ?\n    /*#__PURE__*/\n    // two stacked video elements; we crossfade between them by toggling opacity\n    _jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRefs[0],\n        src: srcs[0],\n        preload: \"auto\",\n        playsInline: true,\n        muted: true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n          transition: 'opacity 320ms ease',\n          opacity: active === 0 ? 1 : 0,\n          zIndex: active === 0 ? 2 : 1\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 184,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRefs[1],\n        src: srcs[1],\n        preload: \"auto\",\n        playsInline: true,\n        muted: true,\n        style: {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          objectFit: 'cover',\n          transition: 'opacity 320ms ease',\n          opacity: active === 1 ? 1 : 0,\n          zIndex: active === 1 ? 2 : 1\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true) : /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        color: '#fff',\n        padding: 20\n      },\n      children: \"No video available \\u2014 add idle and answer videos to src/assets/\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 180,\n    columnNumber: 5\n  }, this);\n}\n_s(PlayerWindow, \"A6w10CSP1BoUCpW0r0SWXwB2qyI=\");\n_c = PlayerWindow;\nvar _c;\n$RefreshReg$(_c, \"PlayerWindow\");","map":{"version":3,"names":["React","useEffect","useRef","useState","idle1","idle2","idle3","idle4","whoAreYou","jsxDEV","_jsxDEV","Fragment","_Fragment","idleVideos","filter","Boolean","PlayerWindow","_s","videoRefs","active","setActive","srcs","setSrcs","length","Math","floor","random","intervalRef","rotationActiveRef","mounted","storageHandler","startIdleRotation","current","clearInterval","setInterval","next","crossfadeTo","loop","muted","stopIdleRotation","ch","window","BroadcastChannel","onmessage","ev","data","type","questionId","console","log","text","toLowerCase","includes","playAnswerOnce","key","newValue","JSON","parse","e","addEventListener","nextSrc","opts","inactive","prev","n","onCanPlay","activeEl","inactiveEl","undefined","p","play","catch","setTimeout","pause","removeEventListener","load","readyState","answerSrc","onEnded","playHelper","close","className","style","height","background","display","alignItems","justifyContent","position","overflow","children","ref","src","preload","playsInline","top","left","width","objectFit","transition","opacity","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","color","padding","_c","$RefreshReg$"],"sources":["/Users/maggiejin/cse495/lizzie-graham/src/screens/PlayerWindow.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\n\n// Import bundled idle assets (these files exist in the project)\nimport idle1 from '../assets/idle/idle1.mp4';\nimport idle2 from '../assets/idle/idle2.mp4';\nimport idle3 from '../assets/idle/idle3.mp4';\nimport idle4 from '../assets/idle/idle4.mp4';\n\n// Import only the answer file that was uploaded\nimport whoAreYou from '../assets/answers/who_are_you.mp4';\n\nconst idleVideos = [idle1, idle2, idle3, idle4].filter(Boolean);\n\nexport default function PlayerWindow() {\n  // two video elements for double-buffering (crossfade)\n  const videoRefs = [useRef(null), useRef(null)];\n  const [active, setActive] = useState(0); // which video element is currently visible (0 or 1)\n  const [srcs, setSrcs] = useState([\n    idleVideos.length ? idleVideos[Math.floor(Math.random() * idleVideos.length)] : '',\n    ''\n  ]);\n  const intervalRef = useRef(null);\n  const rotationActiveRef = useRef(true);\n\n  useEffect(() => {\n    let mounted = true;\n    let storageHandler = null;\n\n    function startIdleRotation() {\n      if (intervalRef.current) clearInterval(intervalRef.current);\n      if (!idleVideos.length) return;\n      rotationActiveRef.current = true;\n      intervalRef.current = setInterval(() => {\n        if (!mounted) return;\n        if (!rotationActiveRef.current) return;\n        const next = idleVideos[Math.floor(Math.random() * idleVideos.length)];\n        crossfadeTo(next, { loop: true, muted: true });\n      }, 7000);\n    }\n\n    function stopIdleRotation() {\n      rotationActiveRef.current = false;\n      if (intervalRef.current) { clearInterval(intervalRef.current); intervalRef.current = null; }\n    }\n\n    startIdleRotation();\n\n    // Listen for broadcast messages to play answer\n    let ch;\n    if ('BroadcastChannel' in window) {\n      ch = new BroadcastChannel('graham-player-channel');\n      ch.onmessage = (ev) => {\n        const data = ev.data;\n        if (!data) return;\n\n        if (data.type === 'playAnswer' && data.questionId) {\n          console.log('Received playAnswer for', data.questionId);\n        }\n\n        if (data.type === 'playAnswerSpoken' && data.text) {\n          const text = (data.text || '').toLowerCase();\n          if (text.includes('who are you') || text.includes(\"who're you\") || text.includes(\"who r u\")) {\n            if (whoAreYou) playAnswerOnce(whoAreYou);\n            return;\n          }\n        }\n\n        if (data.type === 'ping') {\n          // no-op: ensure player is awake\n        }\n      };\n    } else {\n      // fallback: listen to storage events\n      storageHandler = (ev) => {\n        if (ev.key === 'graham-player-msg' && ev.newValue) {\n          try {\n            const data = JSON.parse(ev.newValue);\n            if (data.type === 'playAnswerSpoken' && data.text) {\n              const text = (data.text || '').toLowerCase();\n              if (text.includes('who are you')) {\n                if (whoAreYou) playAnswerOnce(whoAreYou);\n              }\n            }\n          } catch (e) {}\n        }\n      };\n      window.addEventListener('storage', storageHandler);\n    }\n\n    function crossfadeTo(nextSrc, opts = {}) {\n      if (!nextSrc) return;\n      const inactive = 1 - active;\n\n      // set the src on the inactive video element\n      setSrcs((prev) => {\n        const n = [...prev];\n        n[inactive] = nextSrc;\n        return n;\n      });\n\n      // Once the inactive video can play, start it and fade\n      const onCanPlay = () => {\n        const activeEl = videoRefs[active].current;\n        const inactiveEl = videoRefs[inactive].current;\n        if (!inactiveEl) return;\n        try {\n          inactiveEl.loop = !!opts.loop;\n          inactiveEl.muted = opts.muted === undefined ? inactiveEl.muted : opts.muted;\n          const p = inactiveEl.play();\n          if (p && p.catch) p.catch(() => { /* autoplay blocked */ });\n        } catch (e) {}\n\n        // small timeout to ensure play has started before fade\n        setTimeout(() => {\n          // fade by switching active index (opacity transition in JSX)\n          setActive(inactive);\n\n          // pause previous after fade completes to avoid decoding both endlessly\n          setTimeout(() => {\n            try { if (activeEl) { activeEl.pause(); } } catch (e) {}\n          }, 350);\n        }, 80);\n\n        inactiveEl.removeEventListener('canplay', onCanPlay);\n      };\n\n      // attach handler; if already ready, call immediately\n      const inactiveEl = videoRefs[inactive].current;\n      if (inactiveEl) {\n        inactiveEl.addEventListener('canplay', onCanPlay);\n        // ensure it begins loading\n        try { inactiveEl.load(); } catch (e) {}\n        // if already have readyState enough, call handler\n        if (inactiveEl.readyState >= 3) {\n          onCanPlay();\n        }\n      }\n    }\n\n    function playAnswerOnce(answerSrc) {\n      if (!answerSrc) return;\n      stopIdleRotation();\n\n      // Prepare inactive video to play the answer (no loop, not muted)\n      const inactive = 1 - active;\n      setSrcs((prev) => {\n        const n = [...prev];\n        n[inactive] = answerSrc;\n        return n;\n      });\n\n      const inactiveEl = videoRefs[inactive].current;\n      const onEnded = () => {\n        if (!mounted) return;\n        // after short delay, resume idle rotation and pick a random idle\n        setTimeout(() => {\n          if (!mounted) return;\n          const next = idleVideos.length ? idleVideos[Math.floor(Math.random() * idleVideos.length)] : '';\n          crossfadeTo(next, { loop: true, muted: true });\n          startIdleRotation();\n        }, 800);\n\n        if (inactiveEl) inactiveEl.removeEventListener('ended', onEnded);\n      };\n\n      if (inactiveEl) {\n        inactiveEl.loop = false;\n        inactiveEl.muted = false;\n        inactiveEl.addEventListener('ended', onEnded);\n        // ensure it loads and plays; crossfadeTo helper will play when ready\n        const playHelper = () => crossfadeTo(answerSrc, { loop: false, muted: false });\n        playHelper();\n      }\n    }\n\n    return () => { mounted = false; rotationActiveRef.current = false; if (intervalRef.current) clearInterval(intervalRef.current); if (ch) ch.close && ch.close(); if (storageHandler) window.removeEventListener('storage', storageHandler); };\n  }, []);\n\n  return (\n    <div className=\"video-wrap\" style={{height:'100vh',background:'#000',display:'flex',alignItems:'center',justifyContent:'center',position:'relative',overflow:'hidden'}}>\n      {srcs[0] || srcs[1] ? (\n        // two stacked video elements; we crossfade between them by toggling opacity\n        <>\n          <video\n            ref={videoRefs[0]}\n            src={srcs[0]}\n            preload=\"auto\"\n            playsInline\n            muted={true}\n            style={{\n              position: 'absolute',\n              top: 0, left: 0, width: '100%', height: '100%', objectFit: 'cover',\n              transition: 'opacity 320ms ease',\n              opacity: active === 0 ? 1 : 0,\n              zIndex: active === 0 ? 2 : 1\n            }}\n          />\n\n          <video\n            ref={videoRefs[1]}\n            src={srcs[1]}\n            preload=\"auto\"\n            playsInline\n            muted={true}\n            style={{\n              position: 'absolute',\n              top: 0, left: 0, width: '100%', height: '100%', objectFit: 'cover',\n              transition: 'opacity 320ms ease',\n              opacity: active === 1 ? 1 : 0,\n              zIndex: active === 1 ? 2 : 1\n            }}\n          />\n        </>\n      ) : (\n        <div style={{color:'#fff',padding:20}}>No video available â€” add idle and answer videos to src/assets/</div>\n      )}\n    </div>\n  );\n}\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;;AAE1D;AACA,OAAOC,KAAK,MAAM,0BAA0B;AAC5C,OAAOC,KAAK,MAAM,0BAA0B;AAC5C,OAAOC,KAAK,MAAM,0BAA0B;AAC5C,OAAOC,KAAK,MAAM,0BAA0B;;AAE5C;AACA,OAAOC,SAAS,MAAM,mCAAmC;AAAC,SAAAC,MAAA,IAAAC,OAAA,EAAAC,QAAA,IAAAC,SAAA;AAE1D,MAAMC,UAAU,GAAG,CAACT,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC,CAACO,MAAM,CAACC,OAAO,CAAC;AAE/D,eAAe,SAASC,YAAYA,CAAA,EAAG;EAAAC,EAAA;EACrC;EACA,MAAMC,SAAS,GAAG,CAAChB,MAAM,CAAC,IAAI,CAAC,EAAEA,MAAM,CAAC,IAAI,CAAC,CAAC;EAC9C,MAAM,CAACiB,MAAM,EAAEC,SAAS,CAAC,GAAGjB,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;EACzC,MAAM,CAACkB,IAAI,EAAEC,OAAO,CAAC,GAAGnB,QAAQ,CAAC,CAC/BU,UAAU,CAACU,MAAM,GAAGV,UAAU,CAACW,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGb,UAAU,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE,EAClF,EAAE,CACH,CAAC;EACF,MAAMI,WAAW,GAAGzB,MAAM,CAAC,IAAI,CAAC;EAChC,MAAM0B,iBAAiB,GAAG1B,MAAM,CAAC,IAAI,CAAC;EAEtCD,SAAS,CAAC,MAAM;IACd,IAAI4B,OAAO,GAAG,IAAI;IAClB,IAAIC,cAAc,GAAG,IAAI;IAEzB,SAASC,iBAAiBA,CAAA,EAAG;MAC3B,IAAIJ,WAAW,CAACK,OAAO,EAAEC,aAAa,CAACN,WAAW,CAACK,OAAO,CAAC;MAC3D,IAAI,CAACnB,UAAU,CAACU,MAAM,EAAE;MACxBK,iBAAiB,CAACI,OAAO,GAAG,IAAI;MAChCL,WAAW,CAACK,OAAO,GAAGE,WAAW,CAAC,MAAM;QACtC,IAAI,CAACL,OAAO,EAAE;QACd,IAAI,CAACD,iBAAiB,CAACI,OAAO,EAAE;QAChC,MAAMG,IAAI,GAAGtB,UAAU,CAACW,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGb,UAAU,CAACU,MAAM,CAAC,CAAC;QACtEa,WAAW,CAACD,IAAI,EAAE;UAAEE,IAAI,EAAE,IAAI;UAAEC,KAAK,EAAE;QAAK,CAAC,CAAC;MAChD,CAAC,EAAE,IAAI,CAAC;IACV;IAEA,SAASC,gBAAgBA,CAAA,EAAG;MAC1BX,iBAAiB,CAACI,OAAO,GAAG,KAAK;MACjC,IAAIL,WAAW,CAACK,OAAO,EAAE;QAAEC,aAAa,CAACN,WAAW,CAACK,OAAO,CAAC;QAAEL,WAAW,CAACK,OAAO,GAAG,IAAI;MAAE;IAC7F;IAEAD,iBAAiB,CAAC,CAAC;;IAEnB;IACA,IAAIS,EAAE;IACN,IAAI,kBAAkB,IAAIC,MAAM,EAAE;MAChCD,EAAE,GAAG,IAAIE,gBAAgB,CAAC,uBAAuB,CAAC;MAClDF,EAAE,CAACG,SAAS,GAAIC,EAAE,IAAK;QACrB,MAAMC,IAAI,GAAGD,EAAE,CAACC,IAAI;QACpB,IAAI,CAACA,IAAI,EAAE;QAEX,IAAIA,IAAI,CAACC,IAAI,KAAK,YAAY,IAAID,IAAI,CAACE,UAAU,EAAE;UACjDC,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEJ,IAAI,CAACE,UAAU,CAAC;QACzD;QAEA,IAAIF,IAAI,CAACC,IAAI,KAAK,kBAAkB,IAAID,IAAI,CAACK,IAAI,EAAE;UACjD,MAAMA,IAAI,GAAG,CAACL,IAAI,CAACK,IAAI,IAAI,EAAE,EAAEC,WAAW,CAAC,CAAC;UAC5C,IAAID,IAAI,CAACE,QAAQ,CAAC,aAAa,CAAC,IAAIF,IAAI,CAACE,QAAQ,CAAC,YAAY,CAAC,IAAIF,IAAI,CAACE,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC3F,IAAI5C,SAAS,EAAE6C,cAAc,CAAC7C,SAAS,CAAC;YACxC;UACF;QACF;QAEA,IAAIqC,IAAI,CAACC,IAAI,KAAK,MAAM,EAAE;UACxB;QAAA;MAEJ,CAAC;IACH,CAAC,MAAM;MACL;MACAhB,cAAc,GAAIc,EAAE,IAAK;QACvB,IAAIA,EAAE,CAACU,GAAG,KAAK,mBAAmB,IAAIV,EAAE,CAACW,QAAQ,EAAE;UACjD,IAAI;YACF,MAAMV,IAAI,GAAGW,IAAI,CAACC,KAAK,CAACb,EAAE,CAACW,QAAQ,CAAC;YACpC,IAAIV,IAAI,CAACC,IAAI,KAAK,kBAAkB,IAAID,IAAI,CAACK,IAAI,EAAE;cACjD,MAAMA,IAAI,GAAG,CAACL,IAAI,CAACK,IAAI,IAAI,EAAE,EAAEC,WAAW,CAAC,CAAC;cAC5C,IAAID,IAAI,CAACE,QAAQ,CAAC,aAAa,CAAC,EAAE;gBAChC,IAAI5C,SAAS,EAAE6C,cAAc,CAAC7C,SAAS,CAAC;cAC1C;YACF;UACF,CAAC,CAAC,OAAOkD,CAAC,EAAE,CAAC;QACf;MACF,CAAC;MACDjB,MAAM,CAACkB,gBAAgB,CAAC,SAAS,EAAE7B,cAAc,CAAC;IACpD;IAEA,SAASM,WAAWA,CAACwB,OAAO,EAAEC,IAAI,GAAG,CAAC,CAAC,EAAE;MACvC,IAAI,CAACD,OAAO,EAAE;MACd,MAAME,QAAQ,GAAG,CAAC,GAAG3C,MAAM;;MAE3B;MACAG,OAAO,CAAEyC,IAAI,IAAK;QAChB,MAAMC,CAAC,GAAG,CAAC,GAAGD,IAAI,CAAC;QACnBC,CAAC,CAACF,QAAQ,CAAC,GAAGF,OAAO;QACrB,OAAOI,CAAC;MACV,CAAC,CAAC;;MAEF;MACA,MAAMC,SAAS,GAAGA,CAAA,KAAM;QACtB,MAAMC,QAAQ,GAAGhD,SAAS,CAACC,MAAM,CAAC,CAACa,OAAO;QAC1C,MAAMmC,UAAU,GAAGjD,SAAS,CAAC4C,QAAQ,CAAC,CAAC9B,OAAO;QAC9C,IAAI,CAACmC,UAAU,EAAE;QACjB,IAAI;UACFA,UAAU,CAAC9B,IAAI,GAAG,CAAC,CAACwB,IAAI,CAACxB,IAAI;UAC7B8B,UAAU,CAAC7B,KAAK,GAAGuB,IAAI,CAACvB,KAAK,KAAK8B,SAAS,GAAGD,UAAU,CAAC7B,KAAK,GAAGuB,IAAI,CAACvB,KAAK;UAC3E,MAAM+B,CAAC,GAAGF,UAAU,CAACG,IAAI,CAAC,CAAC;UAC3B,IAAID,CAAC,IAAIA,CAAC,CAACE,KAAK,EAAEF,CAAC,CAACE,KAAK,CAAC,MAAM,CAAE,uBAAwB,CAAC;QAC7D,CAAC,CAAC,OAAOb,CAAC,EAAE,CAAC;;QAEb;QACAc,UAAU,CAAC,MAAM;UACf;UACApD,SAAS,CAAC0C,QAAQ,CAAC;;UAEnB;UACAU,UAAU,CAAC,MAAM;YACf,IAAI;cAAE,IAAIN,QAAQ,EAAE;gBAAEA,QAAQ,CAACO,KAAK,CAAC,CAAC;cAAE;YAAE,CAAC,CAAC,OAAOf,CAAC,EAAE,CAAC;UACzD,CAAC,EAAE,GAAG,CAAC;QACT,CAAC,EAAE,EAAE,CAAC;QAENS,UAAU,CAACO,mBAAmB,CAAC,SAAS,EAAET,SAAS,CAAC;MACtD,CAAC;;MAED;MACA,MAAME,UAAU,GAAGjD,SAAS,CAAC4C,QAAQ,CAAC,CAAC9B,OAAO;MAC9C,IAAImC,UAAU,EAAE;QACdA,UAAU,CAACR,gBAAgB,CAAC,SAAS,EAAEM,SAAS,CAAC;QACjD;QACA,IAAI;UAAEE,UAAU,CAACQ,IAAI,CAAC,CAAC;QAAE,CAAC,CAAC,OAAOjB,CAAC,EAAE,CAAC;QACtC;QACA,IAAIS,UAAU,CAACS,UAAU,IAAI,CAAC,EAAE;UAC9BX,SAAS,CAAC,CAAC;QACb;MACF;IACF;IAEA,SAASZ,cAAcA,CAACwB,SAAS,EAAE;MACjC,IAAI,CAACA,SAAS,EAAE;MAChBtC,gBAAgB,CAAC,CAAC;;MAElB;MACA,MAAMuB,QAAQ,GAAG,CAAC,GAAG3C,MAAM;MAC3BG,OAAO,CAAEyC,IAAI,IAAK;QAChB,MAAMC,CAAC,GAAG,CAAC,GAAGD,IAAI,CAAC;QACnBC,CAAC,CAACF,QAAQ,CAAC,GAAGe,SAAS;QACvB,OAAOb,CAAC;MACV,CAAC,CAAC;MAEF,MAAMG,UAAU,GAAGjD,SAAS,CAAC4C,QAAQ,CAAC,CAAC9B,OAAO;MAC9C,MAAM8C,OAAO,GAAGA,CAAA,KAAM;QACpB,IAAI,CAACjD,OAAO,EAAE;QACd;QACA2C,UAAU,CAAC,MAAM;UACf,IAAI,CAAC3C,OAAO,EAAE;UACd,MAAMM,IAAI,GAAGtB,UAAU,CAACU,MAAM,GAAGV,UAAU,CAACW,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGb,UAAU,CAACU,MAAM,CAAC,CAAC,GAAG,EAAE;UAC/Fa,WAAW,CAACD,IAAI,EAAE;YAAEE,IAAI,EAAE,IAAI;YAAEC,KAAK,EAAE;UAAK,CAAC,CAAC;UAC9CP,iBAAiB,CAAC,CAAC;QACrB,CAAC,EAAE,GAAG,CAAC;QAEP,IAAIoC,UAAU,EAAEA,UAAU,CAACO,mBAAmB,CAAC,OAAO,EAAEI,OAAO,CAAC;MAClE,CAAC;MAED,IAAIX,UAAU,EAAE;QACdA,UAAU,CAAC9B,IAAI,GAAG,KAAK;QACvB8B,UAAU,CAAC7B,KAAK,GAAG,KAAK;QACxB6B,UAAU,CAACR,gBAAgB,CAAC,OAAO,EAAEmB,OAAO,CAAC;QAC7C;QACA,MAAMC,UAAU,GAAGA,CAAA,KAAM3C,WAAW,CAACyC,SAAS,EAAE;UAAExC,IAAI,EAAE,KAAK;UAAEC,KAAK,EAAE;QAAM,CAAC,CAAC;QAC9EyC,UAAU,CAAC,CAAC;MACd;IACF;IAEA,OAAO,MAAM;MAAElD,OAAO,GAAG,KAAK;MAAED,iBAAiB,CAACI,OAAO,GAAG,KAAK;MAAE,IAAIL,WAAW,CAACK,OAAO,EAAEC,aAAa,CAACN,WAAW,CAACK,OAAO,CAAC;MAAE,IAAIQ,EAAE,EAAEA,EAAE,CAACwC,KAAK,IAAIxC,EAAE,CAACwC,KAAK,CAAC,CAAC;MAAE,IAAIlD,cAAc,EAAEW,MAAM,CAACiC,mBAAmB,CAAC,SAAS,EAAE5C,cAAc,CAAC;IAAE,CAAC;EAC9O,CAAC,EAAE,EAAE,CAAC;EAEN,oBACEpB,OAAA;IAAKuE,SAAS,EAAC,YAAY;IAACC,KAAK,EAAE;MAACC,MAAM,EAAC,OAAO;MAACC,UAAU,EAAC,MAAM;MAACC,OAAO,EAAC,MAAM;MAACC,UAAU,EAAC,QAAQ;MAACC,cAAc,EAAC,QAAQ;MAACC,QAAQ,EAAC,UAAU;MAACC,QAAQ,EAAC;IAAQ,CAAE;IAAAC,QAAA,EACpKrE,IAAI,CAAC,CAAC,CAAC,IAAIA,IAAI,CAAC,CAAC,CAAC;IAAA;IACjB;IACAX,OAAA,CAAAE,SAAA;MAAA8E,QAAA,gBACEhF,OAAA;QACEiF,GAAG,EAAEzE,SAAS,CAAC,CAAC,CAAE;QAClB0E,GAAG,EAAEvE,IAAI,CAAC,CAAC,CAAE;QACbwE,OAAO,EAAC,MAAM;QACdC,WAAW;QACXxD,KAAK,EAAE,IAAK;QACZ4C,KAAK,EAAE;UACLM,QAAQ,EAAE,UAAU;UACpBO,GAAG,EAAE,CAAC;UAAEC,IAAI,EAAE,CAAC;UAAEC,KAAK,EAAE,MAAM;UAAEd,MAAM,EAAE,MAAM;UAAEe,SAAS,EAAE,OAAO;UAClEC,UAAU,EAAE,oBAAoB;UAChCC,OAAO,EAAEjF,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;UAC7BkF,MAAM,EAAElF,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG;QAC7B;MAAE;QAAAmF,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC,eAEF/F,OAAA;QACEiF,GAAG,EAAEzE,SAAS,CAAC,CAAC,CAAE;QAClB0E,GAAG,EAAEvE,IAAI,CAAC,CAAC,CAAE;QACbwE,OAAO,EAAC,MAAM;QACdC,WAAW;QACXxD,KAAK,EAAE,IAAK;QACZ4C,KAAK,EAAE;UACLM,QAAQ,EAAE,UAAU;UACpBO,GAAG,EAAE,CAAC;UAAEC,IAAI,EAAE,CAAC;UAAEC,KAAK,EAAE,MAAM;UAAEd,MAAM,EAAE,MAAM;UAAEe,SAAS,EAAE,OAAO;UAClEC,UAAU,EAAE,oBAAoB;UAChCC,OAAO,EAAEjF,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC;UAC7BkF,MAAM,EAAElF,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG;QAC7B;MAAE;QAAAmF,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC;IAAA,eACF,CAAC,gBAEH/F,OAAA;MAAKwE,KAAK,EAAE;QAACwB,KAAK,EAAC,MAAM;QAACC,OAAO,EAAC;MAAE,CAAE;MAAAjB,QAAA,EAAC;IAA8D;MAAAY,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK;EAC3G;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACE,CAAC;AAEV;AAACxF,EAAA,CA7MuBD,YAAY;AAAA4F,EAAA,GAAZ5F,YAAY;AAAA,IAAA4F,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}